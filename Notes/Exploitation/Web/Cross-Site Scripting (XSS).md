# Overview
Cross-site scripting (XSS) describes a set of attacks where an adversary injects Javascript into a web application, typically because user input isn't properly sanitised. It is similar to HTML injection, however, it allows for the execution of Javascript code and that makes it a potentially critical vulnerability.

There are 3 main types of XSS and the difference between them lies in the way the injected code reaches the end user.

# Stored XSS
This is the most severe type of XSS. The injected Javascript is sent to the server and the server stores it, for example in a database. When another user goes to retrieve the page that the attacker injected into, the JavaScript is also sent to the user as part of that page and is executed by their browser.

For example, if you can inject `<script>alert("XSS");</script>` into the username field of a user sign-up form, then any other users who visit your user profile later will be prompted with an alert box saying "XSS".

## Blind XSS
Blind XSS is a subset of stored XSS attacks where the injected script is stored by the server in a different part of the application which you don't have direct access and thus can't directly see if your XSS attempt was successful. For example, if the application allows you to send a message to the support team and you can inject into it, the XSS will be executed once the admin panel is visited by a member of the support staff.

# Reflected XSS
Reflected XSS occurs when a server receives data which it then includes in its reply to the submitted request. This is typically exploited by creating a malicious link containing a script inside it and then tricking a user into clicking visiting that URL.

Suppose there is a search bar somewhere in the application, the contents of which are sent as a URL parameter in a `GET` request when a user clicks the search button and are then displayed on the response page in a similar manner:
```
Search results for: <search text>
```
The request could be to the following example URL:

```
example.com/?search=val
```

If your application is vulnerable to XSS, the attacker could craft a malicious URL like the following one:

```
example.com/?search=<script>alert('test')</script>
```

This would inject the Javascript as HTML into the `<search text>` on the response page and the browser would then execute the code.

# DOM-based XSS
DOM-based XSS is a type of XSS where the malicious code is never sent to the server. This commonly occurs when using the fragment part of a URL, or by referencing `document.URL` / `document.location.href`.

This a less common attack nowadays, since most browser automatically escape Javascript in address bars, so DOM-based XSS will only work if you unescape it.

Suppose you have a page on 
```
http://127.0.0.1:8080/example.html
```

You can add fragments to the URL with a # symbol.

```
http://127.0.0.1:8080/example.html#test=val
```

The fragment part (`#test=val`) is never sent to the server - it is only available locally.

Suppose you had the following client-side Javascript code running:

```js
const pos = document.URL.indexOf("test=") + 5;
const value = document.URL.substring(document.URL.indexOf("test=") + 5, document.URL.length);

document.write(value);
```

An attacker could craft the following URL:
```
http://127.0.0.1:8080/example.html#test=<script>alert('xss')</script>
```

However, if a victim clicks on this link, no Javascript should be injected, since the browser would usually automatically escape it - you would get
```
%3Cscript%3Ealert('xss')%3C/script%3E
```
printed on the page. If, however, the Javascript is decoded the client-side code, it will get executed.

# Hunting for XSS
You should try different XSS payloads within every user input field you might find. It is useful to use BurpSuite for that because you might be able to inject into more obscure fiels such as drop-down menus by using a proxy.

You should also be aware that not only can you use the `<script>` tag for injection but you can also include JavaScript in certain HTML attributes of other tags such as the `onload` attribute of the `<img>` tag: `<img onload=alert("XSS") src="example.jpg"/>`.

Depending on where the JavaScript injection happens, you might need to close off a previous tag from the page's source. Imagine that you have an injection happening in `<img src="USER_INPUT"/>`. Your XSS payload will need to close off the image tag before it can insert anything else, so it will probably look like the following: `"/><script>alert("XSS");</script>`. When injected, the page's source code would look like this `<img src=""/><script>alert("XSS");</script>`.
