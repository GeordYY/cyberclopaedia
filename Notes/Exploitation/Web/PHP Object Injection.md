# Introduction
PHP Object Injection is a type of an insecure deserialisation attack.

# Serialisation & Deserialisation
PHP has functionally which allows arbitrary objects to be turned into strings and then later retrieved as objects from those same strings. This is achieved through the `serialize()` and `unserialize()` functions. When an adversary has control over the object which gets deserialised, they can manipulate the input in such a way to make the PHP script perform arbitrary actions.

```php
class User
{
	public $name;
	public $isAdmin;
}

$user = new User();
$user->name = "cr0mll";
$user->isAdmin = False;

echo serialize($user);
```

![](Resources/Images/PHP%20Object%20Injection/Object%20Serialisation.png)

The serialisation string follows the *type:data* paradigm and has the following structure:

|Type|Format|
|:---:|:----:|
|Boolean|`b:value`|
|Integer|`i:value`|
|Float|`d:value`|
|String|`s:length:"value"`|
|Array|`a:size:{values}`|
|Object|`O:name_length:"Class_name":number_of_properties:{properties}`|

Deserialisation is the inverse operation - the `unserialize()` function takes a string and converts it to a PHP object (or normal variable). When the string passed to `unserialize()` is user-controlled, an adversary can craft a custom string which will result in an object with values of the attacker's choice. When these values are later used by the PHP application, they can alter its behaviour. Take a look at the following example:

```php

class LoadFile
{
	public function __tostring()
	{
		return file_get_contents($this->filename);
	}
}

class User
{
	public $name;
	public $isAdmin;
}

$user = unserialize($_POST['user']);

if $user->isAdmin
{
	echo $user->name . " is an admin.\n"
}
else
{
	echo $user->name . " is not an admin.\n"
}
```
