# Chosen Plaintext Attack (CPA)

## Chosen Plaintext Attack (CPA)

A _chosen plaintext attack (CPA)_ models the scenario where an adversary can choose arbitrary plaintexts $$m_1, m_2, ..., m_q$$ and obtain their corresponding ciphertexts $$c_1, c_2, ..., c_q$$ that are all generated by encrypting the messages with the _same_ secret key $$k$$. The adversary's goal is to then decrypt a ciphertext $$c$$ that was obtained by encrypting an unknown message $$m$$, also with the secret key $$k$$.

<details>

<summary><mark style="color:purple;"><strong>Example</strong></mark></summary>

In World War 2, the British would place mines at specific locations and when the Germans found them, they would encrypt their locations and send them to their superiors. The intercepted encrypted messages would later be used at Bletchley Park to break the encryption scheme of the Germans.

</details>

This scenario gives the adversary (partial) control over the messages and ciphertexts it has access to and one can imagine this as the attacker being able to influence to some extent the messages that are exchanged by the two authentic parties Alice and Bob.

{% hint style="info" %}
It is imperative to remember that in the CPA model, all messages are encrypted using the same key.
{% endhint %}

## CPA-Security

So what does it mean for an encryption scheme to be secure under the chosen plaintext thread model?

{% hint style="danger" %}
<mark style="color:red;">**Definition: CPA-Security**</mark>

The efficient adversary Eve is given oracle access to the encryption function $$\textit{Enc}_k$$ for some random secret key $$k$$ and queries it with $$q$$ messages $$m_1, m_2, ..., m_q$$ to obtain their respective ciphertexts $$c_1, c_2, ..., c_q$$. The cipher $$(\textit{Enc}, \textit{Dec})$$ is _CPA-secure_ if for any two messages $$\mu_0, \mu_1$$ and ciphertext $$c$$ belonging to either $$\mu_0$$ or $$\mu_1$$, the adversary $$\textit{Eve}$$ still cannot guess with probability non-negligibly greater than $$\frac{1}{2}$$ whether $$c$$ is the encryption of $$\mu_0$$ or $$\mu_1$$, i.e.

$$\displaystyle\Pr_{k \leftarrow \mathcal{K}, b \leftarrow \{0,1\}}[\textit{Eve}(\textit{Enc}_k(\mu_b)) = \mu_b] \le \frac{1}{2} + \textit{negl}(n)$$
{% endhint %}

<details>

<summary><mark style="color:red;"><strong>Definition Breakdown</strong></mark></summary>

As previously mentioned, the adversary has oracle access to $$\textit{Enc}_k$$ and can thus obtain plaintext-ciphertext pairs $$(m_1, c_1), (m_2,c_2), ..., (m_q, c_q)$$. They then attempt to guess whether a given ciphertext $$c$$ belongs to a message $$\mu_0$$or $$\mu_1$$ (the adversary of course also knows $$\mu_0$$ and $$\mu_1$$). The word "any" in the definition entails that Eve is even free to choose $$\mu_0$$ and $$\mu_1$$ herself. The cipher is considered CPA-secure if even with all this information, the adversary cannot guess with success marginally better than $$\frac{1}{2}$$ if the ciphertext corresponds to $$\mu_0$$ or $$\mu_1$$.

</details>

At first glance, there appears to be something wrong with this definition. The adversary Eve is free to choose both $$m_1, ..., m_q$$ as well as $$\mu_0$$ and $$\mu_1$$. Therefore, it seems that this definition can be trivially broken by Eve simply by choosing $$\mu_0$$ to be the same as one of the previously queried messages $$m_i$$. When Eve is presented with a ciphertext $$c$$ at the end, she can just check if $$c$$ is the ciphertext she obtained when querying $$m_i$$ - since $$\mu_0 = m_i$$, she will know with 100% certainty whether the ciphertext $$c$$ is the encryption of $$\mu_0$$ or $$\mu_1$$. This leads to the following consequence for all CPA-secure ciphers.

{% hint style="success" %}
<mark style="color:green;">**Theorem: Necessity of Randomness**</mark>

There is no CPA-secure cipher with a deterministic encryption function $$\textit{Enc}$$.
{% endhint %}

If $$\textit{Enc}$$ is probabilistic, i.e. it uses internal randomness, then the same message $$m$$ will produce different ciphertexts each time it is encrypted which kills the aforementioned breaking technique stone-dead. It might seem weird that the same message can produce different ciphertexts at first, but this is actually fairly easy to implement. The internal randomness used in each encryption can be encoded in the ciphertext is such a way that it can be recovered later if one knows the secret key $k$.

This property of CPA-security means that it is a _stronger_ notion than [semantic security](index/semantic-security.md) - every CPA-secure cipher is also semantically secure, but the opposite is not necessarily true. In fact, CPA-security is nowadays the bare minimum definition which is expected to be satisfied by a cipher in order to be considered usable, since it provides security in the case of key reuse.
